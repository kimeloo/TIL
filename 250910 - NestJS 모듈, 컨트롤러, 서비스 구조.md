

## 1. NestJS 아키텍처 개요

NestJS는 **모듈화된 아키텍처**를 기반으로 하여 애플리케이션을 구조화합니다. 주요 구성 요소는 다음과 같습니다:

- **Module**: 애플리케이션의 조직 단위
- **Controller**: HTTP 요청을 처리하고 응답을 반환
- **Service (Provider)**: 비즈니스 로직을 담당

## 2. 모듈 (Module)

### 개념
- 애플리케이션을 구조화하는 **기본 단위**
- 관련된 기능들을 하나로 묶어서 관리
- `@Module()` 데코레이터로 정의

### 구조
```typescript
import { Module } from '@nestjs/common';

@Module({
  imports: [],      // 다른 모듈을 가져옴
  controllers: [],  // 이 모듈의 컨트롤러들
  providers: [],    // 이 모듈의 서비스들 (Provider)
  exports: []       // 다른 모듈에서 사용할 수 있도록 내보낼 것들
})
export class AppModule {}
```

### 예제: 사용자 모듈
```typescript
import { Module } from '@nestjs/common';
import { UsersController } from './users.controller';
import { UsersService } from './users.service';

@Module({
  controllers: [UsersController],
  providers: [UsersService],
  exports: [UsersService]  // 다른 모듈에서 사용 가능하도록 내보냄
})
export class UsersModule {}
```

### 모듈의 역할
- **캡슐화**: 관련 기능을 하나의 단위로 묶음
- **재사용성**: 다른 애플리케이션에서도 사용 가능
- **의존성 관리**: 모듈 간의 의존성을 명확히 관리

## 3. 컨트롤러 (Controller)

### 개념
- **HTTP 요청을 처리**하고 클라이언트에게 응답을 반환
- 라우팅과 요청 처리를 담당
- `@Controller()` 데코레이터로 정의

### 기본 구조
```typescript
import { Controller, Get, Post, Body, Param } from '@nestjs/common';

@Controller('users')  // '/users' 경로로 들어오는 요청 처리
export class UsersController {
  
  @Get()  // GET /users
  findAll() {
    return 'This action returns all users';
  }
  
  @Get(':id')  // GET /users/:id
  findOne(@Param('id') id: string) {
    return `This action returns user #${id}`;
  }
  
  @Post()  // POST /users
  create(@Body() createUserDto: any) {
    return 'This action adds a new user';
  }
}
```

### HTTP 메서드 데코레이터
```typescript
@Get()      // GET 요청
@Post()     // POST 요청
@Put()      // PUT 요청
@Delete()   // DELETE 요청
@Patch()    // PATCH 요청
@Options()  // OPTIONS 요청
@Head()     // HEAD 요청
```

### 파라미터 추출
```typescript
@Controller('users')
export class UsersController {
  
  @Get(':id')
  findOne(
    @Param('id') id: string,           // URL 파라미터
    @Query('page') page: string,       // 쿼리 파라미터
    @Body() body: any,                 // 요청 본문
    @Headers('authorization') auth: string  // 헤더
  ) {
    return { id, page, body, auth };
  }
}
```

## 4. 서비스 (Service/Provider)

### 개념
- **비즈니스 로직**을 담당하는 클래스
- 데이터 액세스, 계산, 외부 API 호출 등을 처리
- `@Injectable()` 데코레이터로 정의

### 기본 구조
```typescript
import { Injectable } from '@nestjs/common';

@Injectable()
export class UsersService {
  private readonly users = [];

  create(user: any) {
    this.users.push(user);
    return user;
  }

  findAll() {
    return this.users;
  }

  findOne(id: number) {
    return this.users.find(user => user.id === id);
  }

  update(id: number, updateData: any) {
    const userIndex = this.users.findIndex(user => user.id === id);
    if (userIndex > -1) {
      this.users[userIndex] = { ...this.users[userIndex], ...updateData };
      return this.users[userIndex];
    }
    return null;
  }

  remove(id: number) {
    const userIndex = this.users.findIndex(user => user.id === id);
    if (userIndex > -1) {
      return this.users.splice(userIndex, 1);
    }
    return null;
  }
}
```

### 서비스 활용 예제
```typescript
@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Get()
  findAll() {
    return this.usersService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.usersService.findOne(+id);
  }

  @Post()
  create(@Body() createUserDto: any) {
    return this.usersService.create(createUserDto);
  }
}
```

## 5. 전체 구조 예제

### 프로젝트 구조
```
src/
├── app.module.ts          # 루트 모듈
├── main.ts               # 애플리케이션 진입점
└── users/
    ├── users.module.ts    # 사용자 모듈
    ├── users.controller.ts # 사용자 컨트롤러
    ├── users.service.ts   # 사용자 서비스
    └── dto/
        └── create-user.dto.ts  # 데이터 전송 객체
```

### DTO (Data Transfer Object)
```typescript
export class CreateUserDto {
  readonly name: string;
  readonly email: string;
  readonly age: number;
}
```

### 완성된 서비스
```typescript
import { Injectable, NotFoundException } from '@nestjs/common';
import { CreateUserDto } from './dto/create-user.dto';

@Injectable()
export class UsersService {
  private users = [];
  private currentId = 1;

  create(createUserDto: CreateUserDto) {
    const newUser = {
      id: this.currentId++,
      ...createUserDto,
      createdAt: new Date()
    };
    this.users.push(newUser);
    return newUser;
  }

  findAll() {
    return this.users;
  }

  findOne(id: number) {
    const user = this.users.find(user => user.id === id);
    if (!user) {
      throw new NotFoundException(`User with ID ${id} not found`);
    }
    return user;
  }
}
```

### 완성된 컨트롤러
```typescript
import { 
  Controller, 
  Get, 
  Post, 
  Body, 
  Param, 
  ParseIntPipe 
} from '@nestjs/common';
import { UsersService } from './users.service';
import { CreateUserDto } from './dto/create-user.dto';

@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Post()
  create(@Body() createUserDto: CreateUserDto) {
    return this.usersService.create(createUserDto);
  }

  @Get()
  findAll() {
    return this.usersService.findAll();
  }

  @Get(':id')
  findOne(@Param('id', ParseIntPipe) id: number) {
    return this.usersService.findOne(id);
  }
}
```

### 루트 모듈
```typescript
import { Module } from '@nestjs/common';
import { UsersModule } from './users/users.module';

@Module({
  imports: [UsersModule],
})
export class AppModule {}
```

## 6. 핵심 개념 정리

### 관심사의 분리
- **Controller**: HTTP 요청/응답 처리
- **Service**: 비즈니스 로직 처리
- **Module**: 기능별 조직화

### 계층 구조
```
Client Request
    ↓
Controller (HTTP 처리)
    ↓
Service (비즈니스 로직)
    ↓
Database/External API
```

### 모듈의 특징
- **단일 책임**: 하나의 기능 영역을 담당
- **느슨한 결합**: 모듈 간의 의존성을 최소화
- **높은 응집도**: 관련된 기능들을 하나로 묶음

### 장점
1. **유지보수성**: 코드를 쉽게 찾고 수정할 수 있음
2. **테스트 용이성**: 각 계층을 독립적으로 테스트 가능
3. **재사용성**: 모듈과 서비스를 다른 곳에서 재사용 가능
4. **확장성**: 새로운 기능을 쉽게 추가할 수 있음