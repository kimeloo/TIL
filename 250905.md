# 패턴 매칭 (Java 14+)

## 개요
패턴 매칭은 객체의 구조를 테스트하고, 매칭되면 데이터를 추출하는 프로그래밍 기법입니다. Java 14+에서 점진적으로 도입되어 코드를 더 간결하고 안전하게 작성할 수 있게 해줍니다.

## 발전 과정

### Java 14
- **Switch 표현식** (JEP 361) - 정식 기능으로 추가
- 화살표 표기법 (`->`) 지원
- `yield` 키워드 도입

### Java 16  
- **instanceof 패턴 매칭** (JEP 394) - 정식 기능으로 추가

### Java 17
- **Switch 패턴 매칭** (JEP 406) - 프리뷰 기능으로 도입

### Java 21
- **Switch 패턴 매칭** (JEP 441) - 정식 기능으로 추가

## instanceof 패턴 매칭

### 기존 방식
```java
if (obj instanceof String) {
    String s = (String) obj;
    System.out.println(s.toUpperCase());
}
```

### 패턴 매칭 방식
```java
if (obj instanceof String s) {
    System.out.println(s.toUpperCase());
}
```

## Switch 패턴 매칭

### 기본 예제
```java
interface Shape { }
record Rectangle(double length, double width) implements Shape { }
record Circle(double radius) implements Shape { }

// 기존 방식
public static double getPerimeter(Shape shape) {
    if (shape instanceof Rectangle r) {
        return 2 * r.length() + 2 * r.width();
    } else if (shape instanceof Circle c) {
        return 2 * c.radius() * Math.PI;
    } else {
        throw new IllegalArgumentException("Unrecognized shape");
    }
}

// 패턴 매칭 방식
public static double getPerimeter(Shape shape) {
    return switch (shape) {
        case Rectangle r -> 2 * r.length() + 2 * r.width();
        case Circle c    -> 2 * c.radius() * Math.PI;
        default          -> throw new IllegalArgumentException("Unrecognized shape");
    };
}
```

### 다양한 타입 패턴
```java
record Point(int x, int y) { }
enum Color { RED, GREEN, BLUE; }

static void typeTester(Object obj) {
    switch (obj) {
        case null     -> System.out.println("null");
        case String s -> System.out.println("String: " + s);
        case Color c  -> System.out.println("Color: " + c);
        case Point p  -> System.out.println("Point: " + p);
        case int[] ia -> System.out.println("Array length: " + ia.length);
        default       -> System.out.println("Unknown type");
    }
}
```

## 주요 특징

### 1. 패턴 라벨 우선순위
패턴 라벨은 나타나는 순서대로 테스트되며, 앞선 패턴이 뒤의 패턴을 지배하면 컴파일 오류가 발생합니다.

```java
// 컴파일 오류 - String은 CharSequence의 하위 타입
switch(obj) {
    case CharSequence cs -> System.out.println("CharSequence");
    case String s -> System.out.println("String"); // 오류!
}
```

### 2. 완전성 검사 (Exhaustiveness)
Switch 표현식은 모든 가능한 값에 대해 매칭 라벨이 있어야 합니다.

```java
// 컴파일 오류 - 불완전
static int coverage(Object obj) {
    return switch (obj) {
        case String s  -> s.length();
        case Integer i -> i;
        // default 없음 - 오류!
    };
}
```

### 3. Sealed 클래스 지원
```java
sealed interface S permits A, B, C { }
final class A implements S { }
final class B implements S { }
record C(int i) implements S { }

// default 불필요 - 모든 경우가 커버됨
static int testSealedCoverage(S s) {
    return switch (s) {
        case A a -> 1;
        case B b -> 2;
        case C c -> 3;
    };
}
```

### 4. Null 처리
```java
static void test(Object obj) {
    switch (obj) {
        case null     -> System.out.println("null value");
        case String s -> System.out.println("String: " + s);
        default       -> System.out.println("Other type");
    }
}
```

### 5. 패턴 변수 스코프
```java
// Switch 표현식
switch (obj) {
    case Character c -> {
        // 패턴 변수 c는 이 블록 내에서만 사용 가능
        System.out.println("Character: " + c.charValue());
    }
    case Integer i -> System.out.println("Integer: " + i);
}
```

## 장점

1. **코드 간결성**: 타입 체크와 캐스팅이 동시에 이루어짐
2. **타입 안전성**: 컴파일 타임에 타입 검사 수행
3. **가독성 향상**: 의도가 명확하게 드러남
4. **실수 방지**: 캐스팅 오류 가능성 제거

## 사용 시 주의사항

- Java 17에서는 프리뷰 기능이므로 `--enable-preview` 플래그 필요
- 패턴 변수의 스코프를 정확히 이해하고 사용
- 패턴 라벨의 우선순위 고려
- Sealed 클래스와 함께 사용하면 더욱 효과적