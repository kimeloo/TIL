# 250829 - Program to Interface

## 핵심 개념
인터페이스에 대한 프로그래밍(Programming to Interfaces)은 구현체가 아닌 인터페이스(추상화)에 의존하여 코드를 작성하는 방법론

## 발전 과정

### 1. 구현체에 직접 프로그래밍 (Programming to Classes)
- 클래스 간 직접적인 의존성
- 새로운 기능 추가 시 많은 수정 필요
- 강한 결합(tight coupling) 발생

### 2. 추상 클래스 활용 (Programming to Abstraction)
- 공통 기능을 추상 클래스로 분리
- 클라이언트 코드의 의존성 감소
- 하지만 여전히 서로 다른 개념들이 혼재

### 3. 인터페이스 활용 (Programming to Interfaces)
- 다중 인터페이스 구현으로 관심사 분리
- 각 인터페이스가 명확한 책임 정의
- 느슨한 결합과 높은 확장성 달성

## 장점

### 통일된 메서드
- 인터페이스를 통해 클래스 간 계약(contract) 정의
- 구현 방법이 아닌 **무엇을** 할 것인지에 집중
- 일관된 메서드 네이밍 강제

### 구현체 은닉
- 인터페이스만 노출, 구현 세부사항 숨김
- 작고 명확한 책임을 가진 인터페이스로 응집성 증대
- 코드 이해도 향상 (how가 아닌 what에 집중)

### 테스트 용이성
- 느슨한 결합으로 테스트 더블(test double) 활용 가능
- 명확한 인터페이스로 모킹(mocking) 간편화

### 다중 구현체 지원
- 클라이언트 코드 수정 없이 새로운 구현체 추가
- 기존 구현체를 새로운 구현체로 교체 가능
- JDBC처럼 드라이버만 교체하여 데이터베이스 변경

## SOLID 원칙과의 연관성

- **SRP**: 작은 인터페이스로 명확한 책임 정의
- **OCP**: 느슨한 결합으로 확장에 열려있고 수정에 닫힌 구조
- **LSP**: 상속 계층 설계 시 고려 필요
- **ISP**: 작고 명확한 인터페이스 설계 권장
- **DIP**: 추상화에 의존하여 의존성 역전 원칙 준수

## 관련 디자인 패턴

### 생성 패턴
- Factory, Factory Method, Abstract Factory, Builder
- Dependency Injection 프레임워크 활용

### 구조/행위 패턴
- Adapter, Composite, Decorator, Proxy
- Mediator, Observer, State, Strategy, Visitor

## 단점
- 인터페이스와 클래스 수 증가로 초기 복잡도 상승
- 구현체 인스턴스화를 위한 외부 컴포넌트 필요

## 결론
초보자에게는 복잡해 보일 수 있으나, 좋은 객체지향 원칙을 따르는 방법론. 느슨한 결합, 확장성, 테스트 용이성, 유연성, 가독성을 제공하여 장기적으로 유지보수성이 높은 코드 작성 가능.