
```table-of-contents
```

### code
```java
package boj.etc.boj_15723;  
  
import java.io.BufferedReader;  
import java.io.IOException;  
import java.io.InputStreamReader;  
import java.util.ArrayDeque;  
import java.util.ArrayList;  
import java.util.HashMap;  
import java.util.List;  
import java.util.StringTokenizer;  
  
public class Main {  
  
    static char[] input(StringTokenizer st) {  
        char[] result = new char[2];  
        result[0] = st.nextToken().charAt(0);  
        st.nextToken();  
        result[1] = st.nextToken().charAt(0);  
        return result;  
    }  
  
    public static void main(String[] args) throws IOException {  
        HashMap<Character, List<Character>> graph = new HashMap<>();  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        int n = Integer.parseInt(st.nextToken());  
        for (int i = 0; i < n; i++) {  
            st = new StringTokenizer(br.readLine());  
            char[] ab = input(st);  
            if (!graph.containsKey(ab[0])) {  
                graph.put(ab[0], new ArrayList<>());  
            }  
            graph.get(ab[0]).add(ab[1]);  
        }  
  
        st = new StringTokenizer(br.readLine());  
        int m = Integer.parseInt(st.nextToken());  
        for (int j = 0; j < m; j++) {  
            st = new StringTokenizer(br.readLine());  
            char[] cd = input(st);  
            ArrayDeque<Character> queue = new ArrayDeque<>();  
            queue.offer(cd[0]);  
            char tar = cd[1];  
            boolean ans = false;  
  
            boolean[] visited = new boolean[26];  
            visited[cd[0] - 'a'] = true;  
  
            while (!queue.isEmpty() && !ans) {  
                char cur = queue.poll();  
                List<Character> nextList = graph.getOrDefault(cur, List.of());  
                for (char nxt : nextList) {  
                    if (!visited[nxt - 'a']) {  
                        visited[nxt - 'a'] = true;  
                        queue.offer(nxt);  
                        if (tar == nxt) {  
                            ans = true;  
                            break;  
                        }  
                    }  
                }  
            }  
            System.out.println(ans ? 'T' : 'F');  
        }  
    }  
}
```
## 문제 개요
**전이적 관계(Transitive Relations) 판단**
- 주어진 관계들로부터 특정 관계의 성립 여부를 확인하는 그래프 연결성 문제
- "a is b", "b is c" → "a is c"인지 판단

## 핵심 개념

### 1. 전이적 관계 (Transitive Relation)
- 관계 R에서 (a,b) ∈ R이고 (b,c) ∈ R이면 (a,c) ∈ R인 성질
- 그래프 관점: 노드 간의 경로 존재 여부 확인

### 2. 그래프 모델링
```java
HashMap<Character, List<Character>> graph = new HashMap<>();
```
- **인접 리스트** 방식으로 방향 그래프 구현
- 각 문자(노드)에서 갈 수 있는 문자들을 리스트로 저장

## 알고리즘 분석

### BFS (너비 우선 탐색) 선택 이유
- **목표**: 두 노드 간의 연결성만 확인 (최단 경로 불필요)
- **효율성**: 목표 노드 발견 시 즉시 종료 가능
- **완전성**: 모든 가능한 경로를 체계적으로 탐색

### 핵심 구현 포인트

#### 1. 입력 파싱
```java
static char[] input(StringTokenizer st) {
    char[] result = new char[2];
    result[0] = st.nextToken().charAt(0);  // 첫 번째 문자
    st.nextToken();                       // "is" 건너뛰기
    result[1] = st.nextToken().charAt(0);  // 두 번째 문자
    return result;
}
```

#### 2. 방문 처리 최적화
```java
boolean[] visited = new boolean[26];  // a-z 인덱싱
visited[cd[0] - 'a'] = true;         // O(1) 방문 확인
```
- 문자를 인덱스로 변환하여 **O(1) 방문 확인**
- HashSet 대신 배열 사용으로 **메모리 효율성** 증대

#### 3. 조기 종료 최적화
```java
if (tar == nxt) {
    ans = true;
    break;  // 목표 발견 시 즉시 종료
}
```

## 자료구조 선택의 근거

| 자료구조 | 용도 | 선택 이유 |
|---------|------|-----------|
| `HashMap<Character, List<Character>>` | 그래프 저장 | 문자 기반 키로 빠른 접근 |
| `ArrayDeque<Character>` | BFS 큐 | 양방향 삽입/삭제 효율성 |
| `boolean[26]` | 방문 체크 | 문자-인덱스 매핑으로 O(1) 접근 |

## 시간복잡도 분석

- **전체**: O(M × (V + E))
  - M: 쿼리 개수
  - V: 노드 개수 (최대 26개, 알파벳)
  - E: 간선 개수 (최대 N개)

- **각 쿼리**: O(V + E)
  - BFS의 표준 시간복잡도
  - 최악의 경우 모든 노드와 간선 탐색

## 공간복잡도
- **그래프 저장**: O(V + E)
- **BFS 큐**: O(V) 
- **방문 배열**: O(1) (상수 크기 26)

## 핵심 아이디어
1. **관계의 그래프 변환**: 전이적 관계를 방향 그래프의 경로로 모델링
2. **효율적 탐색**: BFS로 체계적인 연결성 확인
3. **조기 종료**: 목표 발견 시 불필요한 탐색 생략
4. **메모리 최적화**: 문자 특성을 활용한 배열 기반 방문 처리

## 응용 가능한 유사 문제
- 그래프 연결성 판단
- 관계 추론 (family tree, 조직도 등)
- 의존성 그래프 분석