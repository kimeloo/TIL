

## 개요
Redis는 in-memory 데이터베이스로, 메시지 큐로도 활용 가능하다. 주로 List와 Stream 데이터 구조를 사용한다.

## List를 이용한 메시지 큐

### 기본 명령어
- `LPUSH`: 리스트 왼쪽에 추가 (Producer)
- `RPOP`: 리스트 오른쪽에서 제거 (Consumer)
- `BRPOP`: 블로킹 방식으로 대기하며 제거

### 예시
```bash
# Producer
LPUSH queue:emails "user@example.com"

# Consumer
RPOP queue:emails
# 또는 블로킹 방식 (10초 대기)
BRPOP queue:emails 10
```

## Stream을 이용한 메시지 큐 (권장)

### 장점
- 메시지 ID 자동 생성
- Consumer Group 지원
- 메시지 지속성
- 여러 Consumer 분산 처리

### 기본 사용법
```bash
# Producer
XADD mystream * field1 value1 field2 value2

# Consumer
XREAD STREAMS mystream $

# Consumer Group 생성
XGROUP CREATE mystream mygroup $ MKSTREAM

# Consumer Group으로 읽기
XREADGROUP GROUP mygroup consumer1 STREAMS mystream >
```

## 패턴별 사용 사례

### 1. 단순 큐 (FIFO)
- List + LPUSH/RPOP
- 간단한 작업 큐에 적합

### 2. 작업자 풀 패턴
- 여러 Consumer가 하나의 큐에서 작업 분담
- BRPOP으로 블로킹 처리

### 3. 발행-구독 패턴
- Pub/Sub 또는 Stream 사용
- 여러 Consumer가 동일한 메시지 수신

## 고려사항

### 장점
- 높은 성능 (in-memory)
- 간단한 설정
- 다양한 데이터 타입 지원

### 단점
- 메모리 제한
- 데이터 지속성 설정 필요
- 복잡한 라우팅 기능 부족

## 실제 구현 팁

1. **메시지 크기 제한**: 큰 메시지는 별도 저장소 사용
2. **에러 처리**: Dead Letter Queue 패턴 구현
3. **모니터링**: 큐 길이 및 처리 속도 모니터링
4. **백압력**: Consumer 처리 속도 고려한 Producer 제어

Redis는 간단한 메시지 큐 용도로는 충분하지만, 복잡한 메시지 라우팅이나 고가용성이 필요하다면 RabbitMQ나 Apache Kafka 고려 필요.