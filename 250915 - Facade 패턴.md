

## 개념
Facade 패턴은 복잡한 서브시스템에 대한 간단한 인터페이스를 제공하는 구조 패턴이다. 여러 개의 복잡한 클래스들을 하나의 간단한 인터페이스로 감싸서 클라이언트가 쉽게 사용할 수 있도록 한다.

## 목적
- 복잡한 서브시스템을 단순한 인터페이스로 감싸기
- 클라이언트와 서브시스템 간의 결합도 낮추기
- 서브시스템의 복잡성을 숨기고 사용 편의성 증대

## 구조
```
Client -> Facade -> SubSystem1
               -> SubSystem2
               -> SubSystem3
```

## 구현 예시

### Java 예시
```java
// 복잡한 서브시스템들
class CPU {
    public void freeze() { System.out.println("CPU freeze"); }
    public void jump(long position) { System.out.println("CPU jump to " + position); }
    public void execute() { System.out.println("CPU execute"); }
}

class Memory {
    public void load(long position, byte[] data) {
        System.out.println("Memory load data at " + position);
    }
}

class HardDrive {
    public byte[] read(long lba, int size) {
        System.out.println("HardDrive read " + size + " bytes from " + lba);
        return new byte[size];
    }
}

// Facade 클래스
class ComputerFacade {
    private CPU cpu;
    private Memory memory;
    private HardDrive hardDrive;
    
    public ComputerFacade() {
        this.cpu = new CPU();
        this.memory = new Memory();
        this.hardDrive = hardDrive();
    }
    
    public void start() {
        cpu.freeze();
        memory.load(0, hardDrive.read(0, 1024));
        cpu.jump(0);
        cpu.execute();
        System.out.println("Computer started!");
    }
}

// 클라이언트 코드
public class Main {
    public static void main(String[] args) {
        ComputerFacade computer = new ComputerFacade();
        computer.start(); // 간단한 호출로 복잡한 과정 실행
    }
}
```

### JavaScript 예시
```javascript
// 복잡한 서브시스템들
class Database {
    connect() { console.log('Database connected'); }
    query(sql) { console.log(`Executing: ${sql}`); }
    disconnect() { console.log('Database disconnected'); }
}

class Logger {
    log(message) { console.log(`Log: ${message}`); }
}

class Cache {
    get(key) { console.log(`Cache get: ${key}`); }
    set(key, value) { console.log(`Cache set: ${key} = ${value}`); }
}

// Facade 클래스
class DataServiceFacade {
    constructor() {
        this.database = new Database();
        this.logger = new Logger();
        this.cache = new Cache();
    }
    
    getUserData(userId) {
        this.logger.log(`Getting user data for ${userId}`);
        
        // 캐시 확인
        let userData = this.cache.get(userId);
        
        if (!userData) {
            // 데이터베이스에서 조회
            this.database.connect();
            this.database.query(`SELECT * FROM users WHERE id = ${userId}`);
            this.database.disconnect();
            
            // 캐시에 저장
            this.cache.set(userId, 'userData');
        }
        
        this.logger.log(`User data retrieved for ${userId}`);
        return userData;
    }
}

// 클라이언트 코드
const dataService = new DataServiceFacade();
dataService.getUserData(123); // 간단한 호출
```

## 장점
- **단순성**: 복잡한 서브시스템을 간단한 인터페이스로 사용
- **결합도 감소**: 클라이언트와 서브시스템 간의 의존성 최소화
- **유지보수성**: 서브시스템 변경이 클라이언트에 미치는 영향 최소화
- **재사용성**: 공통된 기능을 하나의 인터페이스로 제공

## 단점
- **제한적 기능**: Facade가 제공하지 않는 서브시스템 기능 접근 어려움
- **추가 계층**: 하나의 계층이 더 추가되어 복잡성 증가 가능
- **신 객체 위험**: Facade가 너무 많은 책임을 가질 수 있음

## 실제 사용 사례
- **라이브러리 API**: jQuery가 DOM 조작을 위한 Facade 역할
- **데이터베이스 연결**: ORM이 복잡한 SQL 작업의 Facade
- **운영체제 API**: 복잡한 시스템 호출을 간단한 API로 제공
- **웹 서비스**: RESTful API가 복잡한 비즈니스 로직의 Facade

## Adapter vs Facade
- **Adapter**: 기존 인터페이스를 다른 인터페이스로 변환
- **Facade**: 복잡한 서브시스템을 단순한 인터페이스로 감싸기

## 결론
Facade 패턴은 복잡한 시스템을 단순하게 만들어 사용자 경험을 개선하는 효과적인 디자인 패턴이다. 특히 레거시 시스템이나 복잡한 라이브러리를 사용할 때 유용하다.